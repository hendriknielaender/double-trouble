---
publishDate: "Mar 01 2024"
title: "The Rise and Fall of the SHAFT stack: An Experiment in Tooling"
description: "Learnings from migrating a vercel nextjs appsync app onto a stack made of sqlite, htmx, astro,
fly.io and tuql"
image: "~/assets/images/thumbnails/agile-roadmaps-1.png"
imageCreditUrl: https://midjourney.com
tags: [concept, bun, astro, htmx, fly.io, sqlite]
---

On github we have an app that is called
[party-task-planner](https://github.com/flyck/party-task-planner). It is a basic app which allows
users to create parties, add participants and assign tasks to those participants. An attempt to
organize party planning in a collaborative setting, featuring websockets. It is hosted on Vercel
and uses NextJs and React in the frontend, together with an AWS AppSync graphql api in the backend
to store the data.

Looking at this app, which is basically a CRUD application with little extra functionality, we had
the idea of rebuilding it with different tools, to ideally achieve better development speed, as
well as a better development experience. And so began the inception of SHAFT.

## What is SHAFT?

The stack looks like this:
- Frontend:
  - Htmx
  - Astro
- Backend:
  - Sqlite db
  - [Tuql](https://github.com/bradleyboy/tuql) (turns a sqlite schema into a graphql api)
  - Fly.io hosting
    - [litefs](https://fly.io/docs/litefs/) for distributed sqlite
    - containers app to host the tuql nodejs express api
    - fly can also host static pages

## A Primer on Htmx

Htmx is not really new, but it was new to us going into this experiment. What is Htmx? Htmx
competes as a frontend library, and plays in the same category as react. It has recently gotten
much more popularity, getting covered by prime and more (TODO link). At the same time these days
there seems to be a general fatigue around react development, which we also felt when created the
party-task-planner.

How does Htmx look in practice? Here we have simple example from the
[docs](https://htmx.org/attributes/hx-get/):
```html
<div hx-get="/example">
  Get Some HTML
</div>
```

This snippet will cause the div to issue a GET to /example and swap the returned HTML into the
innerHTML of the div. Htmx has a wide range of these html attributes, which in combination act as
a complete frontend library.

Htmx advertises on their website: `high power tools for HTML`. But what is the limit of these
tools, and what is their extended purpose?  It seems that the Htmx approach is one which tries to
avoid javascript, and have the frontend build only on html attributes which are then interpreted
by htmx. This is supported by the following haiku featured on [htmx.org](htmx.org):

```
javascript fatigue:
longing for a hypertext
already in hand
```

### Htmx Templating: Frontend vs Backend

With htmx, you will need templates either on the frontend or the backend. These can be seen as two
completely different sides of Htmx, and going either route will lead you down two totally
different rabbit holes.

#### Frontend Templating

Htmx does [officialy support](https://htmx.org/extensions/client-side-templates/) parsing JSON
responses from REST or GraphQL, and pass them on to templates, like mustacheJS, handlebars, or
more.

The advantage here is that the styling and visualization remains in the frontend, and we can
easily integrate with existing apis.

An example from the [docs](https://htmx.org/extensions/client-side-templates/):
```html
  <div hx-ext="client-side-templates">
    <button hx-get="https://jsonplaceholder.typicode.com/users"
            hx-swap="innerHTML"
            hx-target="#content"
            mustache-array-template="foo">
      Click Me
    </button>

    <p id="content">Start</p>

    <template id="foo">
      {{#data}}
      <p> {{name}} at {{email}} is with {{company.name}}</p>
      {{/data}}
    </template>
  </div>
```

We decided to go for this route, to really see how far it could take us. For our example of the
SHAFT stack, with the autogenerated graphql API, we needed use this approach in order to
completely avoid having to write a backend at all.


The disadvantage of trying to talk to normal REST and GraphQL apis via Htmx is that it doesn't
feel like it's the intended use. Going this route, many javascript work-arounds were needed. While
the Htmx docs don't point this out as wrong, it certainly doesn't feel great to write this low
level of Javascript again.

#### Backend Templating

It seems that the favorite of Htmx is the one of the backend returning html. This means this
backend will need be able to do have html templating, unless you are willing to define your html
responses in some sort of long sausage string.

With the Htmx sentiment of "javascript fatigue", a backend written in javascript wouldnt make too
much sense. You could find yourself in comical situations, writing the same or similar javascript
as with react, but just somewhere else. Instead, a popular combination for Htmx is Golang as the
backend.

This in itself is a complete *paradigm shift* from normal fullstack development. There is no
longer a clear seperation between frontend and the backend. If you have a frontend engineer, he
will need to know the backend language in order to do changes there.


The positive side of the shift is the complete skipping of types. With Htmx and backend
templating, something like [trpc](https://trpc.io) is not needed. The backend already knows the
types of the data, and immediately creates the related html too.

## Htmx and Astro

While Htmx as a frontend library doesnt need a framework like Astro, on first glance it seems like
they would be best friends. They both share a the same bias against Javascript and both have a
love for html.

From the astro [docs](https://docs.astro.build/en/basics/astro-syntax/): `If you know HTML, you
already know enough to write your first Astro component.`. Astros approach is to include as little
javascript as possible, to have the most performant site possible. Loading in javascript and even
frontend library components via the concept of `islands` is still possible, but the idea is that
those are the exception.

Migrating a small app to this combination revealed certain attributes:
- `Pro: Hot reload`: While Htmx can live simply in a html page which is displayed in the browser,
  having the automatic hot-reload on save from Astro was nice.
- `Pro: Components`: Astros buildin components make it easy to structure the html into different
  components and have a somewhat orderly project structure.
- `Pro: Easier Debugging`: Astros dev tools can point exactly to the file where the problem
  exists. In raw html there is much less support during development.
- `Neutral: Astros Static Page Router`: Astro by default functions as a static site generator,
  which can be configured via the [output
  mode](https://docs.astro.build/en/basics/rendering-modes/). To still have a static site for our
  app migration, we had to make a compromise in the route:
  - The original app had a route `/[partyid]` to navigate to the party infos
  - With the astro static mode, we can replicate this with `/party?id=partyId`

  There might be many apps which don't havee such routing needs, or it might be that the astro
  `server` or `hybrid` modes completely solve this issue, but we haven't yet explored in this
  direction (TODO?).
- `Con: Templating`: Astros [templates](https://docs.astro.build/en/basics/astro-syntax/) are only
  evaluated on their initial render. This rules them out as htmx response templates and you'll
  need another templating library like mustache.


## Fly.io and Tuql
