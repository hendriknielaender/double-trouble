---
publishDate: "March 29 2025"
title: "Uncovering the Holygrail: htmx, tailwind & alpine"
description: ""
image: ~/assets/images/thumbnails/holygrail.webp
imageCreditUrl: https://www.chatgpt.com
tags: [alpine.js, htmx, tailwindcss, mpa, interactive UI]

---
import {CodePreview, CodePreviewScripts} from "~/components/atoms/CodePreview.tsx";

<CodePreviewScripts />

The past few years for us, in retrospective atleast, stood under one big common theme: The search
for better tools. Not only bigger tools, but tools that help us ship.

During this time, we have always been huge fans of bun and tailwind, but last year we've also
taken htmx more seriously. Building with it ontop of cloudflaire, let us cover the basics of app
building with htmx[↗](/post/howto-htmx-astrodb-astrossr). This year, we have a big project coming
up. It's going to be the biggest thing we've ever build together, and it's going to be build with
htmx and bun.

But there was a missing piece. With htmx, we found ourselves writing some last-mile
javascript[↗](/post/howto-htmx-astrodb-astrossr#is-htmx-the-ultimate-choice), which we didnt have
to write in regular frontend frameworks. The effort seemed justified, but it didn't feel great. To
fill this gap, Hendrik brought [alpine.js](https://alpinejs.dev/) into the mix, and it filled the
spot perfectly. As we're enjoying the experience with it, we already have a few techniques to
share, but also the bigger picture to discuss.

## What is Alpine?

Alpine lets you **embed reactive state and behavior directly in your HTML**. You include it via a
simple `<script>` tag (no build process needed), then you can use directives like `x-data` to
define component state, `x-text` or `x-html` to bind data to the DOM, `x-on:click` (shorthand
`@click`) to listen for events, `x-show` to conditionally display elements, `x-for` for loops,
[and so on](https://alpinejs.dev/start-here). All of this happens *declaratively in the HTML*. For
example, a basic Alpine counter component looks like:

<CodePreview previewCode={`<div x-data="{ count: 0 }" class="flex flex-col">
  <span x-text="count" class="text-center"></span>
  <button class="rounded-sm px-2 bg-blue-800" x-on:click="count++">Increment</button>
</div>`}>

```html
<div x-data="{ count: 0 }">
  <span x-text="count"></span>
  <button x-on:click="count++">Increment</button>
</div>
```

</CodePreview>

Note that the value in the x-data always have to be a json, though you can also include central
functions. This can be a point of confusion when being in the heat of the moment, as every other
property in alpine is straight javascript.

### Example 1: Dialog

The following example creates a simple [html
dialog](https://developer.mozilla.org/de/docs/Web/HTML/Element/dialog) as a modal. The native html
dialog comes with many interactivity batteries included, while it lacks behind in some other aspects,
for example transition effects on dialog closing.

<CodePreview previewCode={`<div x-data="" class="flex w-full">
  <button class="bg-blue-600 rounded-sm p-1 mx-auto"
    x-on:click="$refs.dialog.showModal();">open</button>
  <dialog x-ref="dialog"
    x-on:click="if (!$refs['dialog-inner'].contains($event.target)) {$refs.dialog.close();}"
    class="p-0 backdrop:bg-gray-400/50 mx-auto my-auto rounded-sm">
    <div x-ref="dialog-inner" class="p-4 space-y-4 flex flex-col">
      <span>This is an open dialog window</span>
      <button x-on:click="$refs.dialog.close();" class="bg-blue-600 rounded-sm">
        close
      </button>
    </div>
  </dialog>
</div>`}>

```html
<div x-data="" class="flex w-full">
  <button class="bg-blue-600 rounded-sm p-1 mx-auto"
    x-on:click="$refs.dialog.showModal();">open</button>
  <dialog x-ref="dialog"
    x-on:click="if (!$refs['dialog-inner'].contains($event.target)) {$refs.dialog.close();}"
    class="p-0 backdrop:bg-gray-400/50 mx-auto my-auto rounded-sm">
    <div x-ref="dialog-inner" class="p-4 space-y-4 flex flex-col">
      <span>This is an open dialog window</span>
      <button x-on:click="$refs.dialog.close();" class="bg-blue-600 w-min rounded-sm">
        close
      </button>
    </div>
  </dialog>
</div>
```

</CodePreview>

The snippet above still serves as a great example for the `$refs` utility, which allows easy
access of elements with by their `x-ref` property. For this to work, `x-ref` needs to be within a
`x-data` property, as this is the scope it is being bound to.

### Example 2: Dropdown

The following snippet shows an example dropdown in alpine.js. It's an adapted example from [the
docs](https://alpinejs.dev/component/dropdown), focusing more on only the alpine basics rather
than all the accessibility and styling shebangs.

```html
<div class="relative"
     x-data="{selected: 'nothing', open: true,
              toggle() {this.open = !this.open}}">

    <div x-text="selected" class="text-gray-200"></div>
    <!-- Button -->
    <button x-on:click="toggle()" type="button"
            class="relative flex items-center py-2 rounded-lg bg-white">
        <span>Options ↓</span>
    </button>

    <!-- Panel -->
    <div
        x-show="open" x-cloak x-transition.origin.top.left
        x-on:click.outside="open=false"
        class="absolute left-0 min-w-48 rounded-lg mt-2 z-10 origin-top-left bg-white text-gray-800"
    >
        <button x-on:click="selected='new task'; toggle()"
            class="p-2 w-full rounded-md text-left hover:bg-gray-50">
            New Task
        </button>
        <button x-on:click="selected='edit task'; toggle()"
            class="p-2 w-full rounded-md text-left hover:bg-gray-50">
            Edit Task
        </button>
        <!-- more options -->
    </div>
</div>
```

This example leverages `x-on:click` event handlers to modify the selected value, which is
displayed via `x-text`. A key element is also `x-show` and `x-cloak`, which together hide the
dropdown element as long as alpine is still getting loaded, or while the open is set to false.

## Alpine & Htmx Synergies / Overlap

While alpine manages client-side interactivity, and htmx manages server-side integration, both try
to potentially stand on their own, so naturally there is a bit of overlap.

### Clicks

One of these overlaps is handling the click event trigger, which both htmx (`hx-trigger='click'`)
and alpine (`x-on:click='foo=true'`) can do.

```html
<div x-data="{isClicked: false}">
  <button
    hx-put="/"
    hx-trigger="click"
    x-on:click="isClicked = !isClicked"
  >
    Click me
  </button>
  <div x-text="isClicked"></div>
</div>
```

In this case, both click-effects will be triggered and processed, which is also what we would
expect. This is an overlap which is rather hypothetical, and rarely matters in

### X-Bind

X-Bind is an alpine directive, which allows to set html attributes based on the result of
javascript expressions. In the following example, we set the path parameters for a conditional
server request, by compiling the interpolated string for htmx as the value of `x-bind`.

```html
<div
  x-ref="deep-link-dialog"
  x-data="{id: new URLSearchParams(location.search).get('id')}"
  x-bind:hx-trigger="`${id !== null ? 'load': ''}`"
  x-bind:hx-get="`/api/tasks/${id}`"
  hx-swap="innerHTML"
></div>
```

Note that this example could also be implemented with pure htmx, if the parameter was [not a path
parameter](https://github.com/bigskysoftware/htmx/issues/1202) (using `hx-params` &
`hx-on:htmx:validation:validate` to skip the request), or by simply relying on the
`HX-Current-URL` and parsing that in the backend. However, combining alpine and htmx with `x-bind`
we get a traditional REST request using only simple methods.


### Events

Both htmx and alpine have helper functions to emit events, and both can natively catch all sorts
of events, includign custom ones. The following example shows how both could be used
interchangibly, to increase an alpine counter.

```html
<div x-data="{counter: 0}" x-on:notify="counter++" id="counter">
  <div x-text="counter"></div>
  <div class="flex w-full gap-2" class="flex flex-row">
    <button class="bg-blue-400 p-2 rounded-sm" @click="$dispatch('notify')">Emit alpine event!</button>
    <button class="bg-orange-400 p-2 rounded-sm" @click="htmx.trigger('#counter', 'notify')">Emit htmx event!</button>
  </div>
</div>
```

Since both libraries use native events under the hood, the can listen to each others events
without any extra config, which again leads to easy and great synergies.

By working only with the raw essentials of html and javascript in the browser, these two tools can
work together great. Both tools having a different focus, they complement each other and give
options, which would otherwise not be comfortable.

## No-Build Frontends

All of the examples in this post could actually be used without any build tools. Any of the
previous examples could be copied into the following template, and they would instantly work.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Htmx / Alpine Overlap</title>
    <script src="https://unpkg.com/htmx.org@2.0.4/dist/htmx.min.js" ></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://unpkg.com/@tailwindcss/browser@4.0.14/dist/index.global.js" ></script>
  </head>
  <body>
    <!-- your awesome html goes here -->
  </body>
</html>
```

Running a few examples locally is actually so easy in combination with buns new html-server
(introduced in [bun v1.2.3](https://bun.sh/blog/bun-v1.2.3)). To serve a few html files with bun,
simply place them in the same directory and type:

```
bun *.html
```

Bun will serve these html files locally and can simulate the basic htmx flow, as one html file may
load contents from another via htmx.

This will give the advantage of avoiding any CORS errors, and hot-reloading changes in the html
files via bun.


## Why we need simpler tools

[Ryan Carniato](https://x.com/RyanCarniato), the author of [SolidJS](https://www.solidjs.com/),
and a core member of [markoJS](https://markojs.com/), said it himself in his frontend framework
[mega post](https://dev.to/this-is-learning/javascript-frameworks-heading-into-2025-hkb) at the
start of this year:

> The quest for simplicity hasn't resulted in making web development simpler.

He mentions tighter economic times increase the pressure to really get things done, which couldn't
be more true. He also recognizes HTMX as a great option, too, while his heart definitely still
beats for web compilers.

While we agree with Ryan's analysis, our take-away is a bit different. We see that complex tools,
often hurt us developers more than we would like to admit. And we know that, not only since the
release of [grugbrain.dev](https://grugbrain.dev/).

When a problem in react is solved according to the holy rules of react, in a way which is as
performant as it can be, there is a bit of a hindsight bias. Things weren't that hard after all,
next time it will be easier. Meanwhile hours, days or weeks have been sunk into this problem,
while we as developers still feel accomplished in the end.

But all this struggle for what? To build the millionth web form, to build a dropdown, which can
also expand in this weird way, to build redirects or autofills. We are shooting with huge guns at
problems which have existed almost since the beginning of the web. It is this that is not
justified, and it's honestly also not fun. It doesn't give the joy of building and moving
swiftly. It's time to go simpler.

## Section on Performance(?)

- Htmx and alpine js, being in the order of a few tens of kilbytes (16 and 17kB respectively), are
  much smaller than most JS frameworks. React and Angular being more in the 40-60kB area
  [source](https://blog.logrocket.com/angular-vs-react-vs-vue-js-comparing-performance/).
- Instead of going for a heavy SPA approach, the server-rendered html require only minimal
  javascript in the browser to manage interactivity, while the html is mostly
  server-rendered. This has the added benefit of the page always being indexable by search
  engines, since it is just HTML.

TODO take more of the good bits from the gpt-posts

## Rounding up

Our bet on htmx and Alpine.js is that it's going to help us to build things faster and
simpler. Having small docs for just a handful of options, together with stable APIs, to us that is
not a bug. It's a massive feature.

We're eager to dig deeper into building with alpine.js and htmx, and share our continued
findings. As we are building with it on our huge project, which should launch by the end of this
summer, we can hopefully turn some heads and convince some folks to turn back to simplicity, too.
